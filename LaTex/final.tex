\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Numeric Methods Benchmark Analysis}

\author{\IEEEauthorblockN{1\textsuperscript{st} Santiago Valencia Arango}
\IEEEauthorblockA{\textit{dept. of science} \\
\textit{EAFIT}\\
Medellín, Colombia \\
svalenciaa@eafit.edu.co}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Juan Manuel Young Hoyos}
\IEEEauthorblockA{\textit{dept. of science} \\
\textit{EAFIT (of Aff.)}\\
Medellín, Colombia \\
jmyoungh@eafit.edu.co}
}

\maketitle

\begin{abstract}
The idea of this project is to test out if it is worth it to use C++ instead of Python for
algorithms of some numeric methods, like finding roots of non-linear equations using
Newton-Raphson's method.
\end{abstract}

\begin{IEEEkeywords}
Numeric methods, C++, Python, algorithms, insert
\end{IEEEkeywords}

\section{Introduction}
Why this project? the aim of this project is to be able to analyze and draw a conclusion to 
the question, is it worth spending more time programming in C ++? Or is it more profitable to do 
this type of algorithms using Python and its libraries in terms of development time and program performance?

\section{What will we test?}

\subsection{Algorithms}
In this project we will only find roots of an equation using:
\begin{itemize}
    \item Newton-Rapshon method.
    \item Bisection method.
    \item Secant method.
    \item Regula-Falsi method.
    \item Fixed-point iteration method.
\end{itemize}

\subsection{G++ compiler}
\textit{g++ (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0}

\subsection{Python interpreter}
\textit{Python 3.8.5}

\section{Newton-Raphson comparison}
\subsection{Variables}

Equation: \(x^3 + x^2 + 3\) 

Initial point: \(-20\)

Tolerance: \(0.00001\) 

Maximum number of iterations: \(20\)

\section{Newton-Raphson comparison}
\subsection{Variables}

Equation: \(x^3 + x^2 + 3\) 

Initial point: \(-20\)

Tolerance: \(0.00001\) 

Maximum number of iterations: \(20\)

\section{Newton-Raphson comparison}
\subsection{Variables}

Equation: \(x^3 + x^2 + 3\) 

Initial point: \(-20\)

Tolerance: \(0.00001\) 

Maximum number of iterations: \(20\)

\section{Newton-Raphson comparison}
\subsection{Variables}

Equation: \(x^3 + x^2 + 3\) 

Initial point: \(-20\)

Tolerance: \(0.00001\) 

Maximum number of iterations: \(20\)

\section{Newton-Raphson comparison}
\subsection{Variables}

Equation: \(x^3 + x^2 + 3\) 

Initial point: \(-20\)

Tolerance: \(0.00001\) 

Maximum number of iterations: \(20\)


\section{Conclusion}
In conclusion the construction of root equation methods in both python and c++ are relatively simple, the comparison was based on discovering the performance of these numerical methods in a interpreted language vs a compiled language, in this case the comparison between python and c++ gives us some pretty clear results, c++ is much more efficient executing the algorithms, and not constituting a very high development complexity with respect to python, because normally due to the convenience of the libraries in python usually the development of these methods are faster, but if you are looking for efficiency in the results should be developed with c++. 

With respect to the level of knowledge that you must have to develop these algorithms should be much higher in the case of c++, compared to python. 

A topic that was not treated in this project and that is raised as future work is the development of these methods in python but to use an extension of c++ that allows the execution of functions and declaration of variables with c++ allowing the facility of python and the great power of the compiler of c++ and its optimizations. 

\begin{thebibliography}{00}
\bibitem{b1} Burden, Richard L. and Faires, Duglas. Análisis Numérico. Editorial Thomson. 9 Edición 2011.
\end{thebibliography}

\end{document}
